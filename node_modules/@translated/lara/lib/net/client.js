"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LaraClient = void 0;
const sdk_version_1 = require("../sdk-version");
const crypto_1 = __importDefault(require("../crypto"));
const errors_1 = require("../errors");
function parseContent(content) {
    if (content === undefined || content === null)
        return content;
    if (Array.isArray(content))
        return content.map(parseContent);
    if (typeof content === "string") {
        // Test if it's a date
        if (content.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.[0-9]{3}Z$/))
            return new Date(content);
        else
            return content;
    }
    if (typeof content == "object") {
        const result = {};
        for (const [key, value] of Object.entries(content)) {
            const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
            result[camelKey] = parseContent(value);
        }
        return result;
    }
    return content;
}
/** @internal */
class LaraClient {
    constructor(accessKeyId, accessKeySecret) {
        this.crypto = (0, crypto_1.default)();
        this.extraHeaders = {};
        this.accessKeyId = accessKeyId;
        this.accessKeySecret = accessKeySecret;
    }
    setExtraHeader(name, value) {
        this.extraHeaders[name] = value;
    }
    get(path, params, headers) {
        return this.request("GET", path, params, undefined, headers);
    }
    delete(path, params, headers) {
        return this.request("DELETE", path, params, undefined, headers);
    }
    post(path, body, files, headers) {
        return this.request("POST", path, body, files, headers);
    }
    put(path, body, files, headers) {
        return this.request("PUT", path, body, files, headers);
    }
    async request(method, path, body, files, headers) {
        if (!path.startsWith("/"))
            path = "/" + path;
        const _headers = {
            "X-HTTP-Method-Override": method,
            "X-Lara-Date": new Date().toUTCString(),
            "X-Lara-SDK-Name": "lara-node",
            'X-Lara-SDK-Version': sdk_version_1.version,
            ...this.extraHeaders,
            ...headers
        };
        if (body) {
            body = Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== undefined && v !== null));
            if (Object.keys(body).length === 0)
                body = undefined;
            if (body) {
                const jsonBody = JSON.stringify(body, undefined, 0);
                _headers["Content-MD5"] = await this.crypto.digest(jsonBody);
            }
        }
        let requestBody = undefined;
        if (files) {
            // validate files
            for (const [key, file] of Object.entries(files))
                files[key] = this.wrapMultiPartFile(file);
            _headers["Content-Type"] = "multipart/form-data";
            requestBody = Object.assign({}, files, body);
        }
        else {
            _headers["Content-Type"] = "application/json";
            if (body)
                requestBody = body;
        }
        const signature = await this.sign(method, path, _headers);
        _headers["Authorization"] = `Lara ${this.accessKeyId}:${signature}`;
        const response = await this.send(path, _headers, requestBody);
        if (200 <= response.statusCode && response.statusCode < 300) {
            return parseContent(response.body.content);
        }
        else {
            const error = response.body.error || {};
            throw new errors_1.LaraApiError(response.statusCode, error.type || "UnknownError", error.message || "An unknown error occurred");
        }
    }
    async sign(method, path, headers) {
        const date = headers["X-Lara-Date"].trim();
        const contentMD5 = (headers["Content-MD5"] || "").trim();
        const contentType = (headers["Content-Type"] || "").trim();
        const httpMethod = (headers["X-HTTP-Method-Override"] || method).trim().toUpperCase();
        const challenge = `${httpMethod}\n${path}\n${contentMD5}\n${contentType}\n${date}`;
        return await this.crypto.hmac(this.accessKeySecret, challenge);
    }
}
exports.LaraClient = LaraClient;
