"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Translator = exports.Documents = exports.Memories = void 0;
const net_1 = __importDefault(require("../net"));
const s3_1 = __importDefault(require("../net/s3"));
const models_1 = require("./models");
const errors_1 = require("../errors");
class Memories {
    constructor(client) {
        this.client = client;
        this.pollingInterval = 2000;
    }
    async list() {
        return await this.client.get("/memories");
    }
    async create(name, externalId) {
        return await this.client.post("/memories", {
            name, external_id: externalId
        });
    }
    async get(id) {
        try {
            return await this.client.get(`/memories/${id}`);
        }
        catch (e) {
            if (e instanceof errors_1.LaraApiError && e.statusCode === 404) {
                return null;
            }
            throw e;
        }
    }
    async delete(id) {
        return await this.client.delete(`/memories/${id}`);
    }
    async update(id, name) {
        return await this.client.put(`/memories/${id}`, { name });
    }
    async connect(ids) {
        const memories = await this.client.post("/memories/connect", {
            ids: Array.isArray(ids) ? ids : [ids]
        });
        return (Array.isArray(ids) ? memories : memories[0]);
    }
    async importTmx(id, tmx, gzip = false) {
        return await this.client.post(`/memories/${id}/import`, {
            compression: gzip ? 'gzip' : undefined
        }, {
            tmx
        });
    }
    async addTranslation(id, source, target, sentence, translation, tuid, sentenceBefore, sentenceAfter) {
        const body = {
            source,
            target,
            sentence,
            translation,
            tuid,
            sentence_before: sentenceBefore,
            sentence_after: sentenceAfter
        };
        if (Array.isArray(id)) {
            body.ids = id;
            return await this.client.put("/memories/content", body);
        }
        else {
            return await this.client.put(`/memories/${id}/content`, body);
        }
    }
    async deleteTranslation(id, source, target, sentence, translation, tuid, sentenceBefore, sentenceAfter) {
        const body = {
            source,
            target,
            sentence,
            translation,
            tuid,
            sentence_before: sentenceBefore,
            sentence_after: sentenceAfter
        };
        if (Array.isArray(id)) {
            body.ids = id;
            return await this.client.delete("/memories/content", body);
        }
        else {
            return await this.client.delete(`/memories/${id}/content`, body);
        }
    }
    async getImportStatus(id) {
        return await this.client.get(`/memories/imports/${id}`);
    }
    async waitForImport(mImport, updateCallback, maxWaitTime) {
        const start = Date.now();
        while (mImport.progress < 1.) {
            if (maxWaitTime && Date.now() - start > maxWaitTime)
                throw new errors_1.TimeoutError();
            await new Promise(resolve => setTimeout(resolve, this.pollingInterval));
            mImport = await this.getImportStatus(mImport.id);
            if (updateCallback)
                updateCallback(mImport);
        }
        return mImport;
    }
}
exports.Memories = Memories;
class Documents {
    constructor(client) {
        this.client = client;
        this.s3Client = (0, s3_1.default)();
    }
    async upload(file, filename, source, target, options) {
        const { url, fields } = await this.client.get(`/documents/upload-url`, { filename });
        await this.s3Client.upload(url, fields, file);
        return this.client.post('/documents', {
            source,
            target,
            s3key: fields.key,
            adapt_to: options === null || options === void 0 ? void 0 : options.adaptTo,
        });
    }
    async status(id) {
        return await this.client.get(`/documents/${id}`);
    }
    async download(id, options) {
        const { url } = await this.client.get(`/documents/${id}/download-url`, {
            output_format: options === null || options === void 0 ? void 0 : options.outputFormat,
        });
        return await this.s3Client.download(url);
    }
    async translate(file, filename, source, target, options) {
        const uploadOptions = (options === null || options === void 0 ? void 0 : options.adaptTo) ? { adaptTo: options.adaptTo } : undefined;
        const { id } = await this.upload(file, filename, source, target, uploadOptions);
        const downloadOptions = (options === null || options === void 0 ? void 0 : options.outputFormat) ? { outputFormat: options.outputFormat } : undefined;
        const pollingInterval = 2000;
        const maxWaitTime = 1000 * 60 * 15; // 15 minutes
        const start = Date.now();
        while (Date.now() - start < maxWaitTime) {
            await new Promise(resolve => setTimeout(resolve, pollingInterval));
            const { status, errorReason } = await this.status(id);
            if (status === models_1.DocumentStatus.TRANSLATED)
                return await this.download(id, downloadOptions);
            if (status === models_1.DocumentStatus.ERROR) {
                throw new errors_1.LaraApiError(500, "DocumentError", errorReason);
            }
        }
        throw new errors_1.TimeoutError();
    }
}
exports.Documents = Documents;
class Translator {
    constructor(credentials, options) {
        this.client = (0, net_1.default)(credentials.accessKeyId, credentials.accessKeySecret, options === null || options === void 0 ? void 0 : options.serverUrl);
        this.memories = new Memories(this.client);
        this.documents = new Documents(this.client);
    }
    async getLanguages() {
        return await this.client.get("/languages");
    }
    async translate(text, source, target, options) {
        return await this.client.post("/translate", {
            q: text, source, target, source_hint: options === null || options === void 0 ? void 0 : options.sourceHint,
            content_type: options === null || options === void 0 ? void 0 : options.contentType, multiline: (options === null || options === void 0 ? void 0 : options.multiline) !== false,
            adapt_to: options === null || options === void 0 ? void 0 : options.adaptTo, instructions: options === null || options === void 0 ? void 0 : options.instructions,
            timeout: options === null || options === void 0 ? void 0 : options.timeoutInMillis, priority: options === null || options === void 0 ? void 0 : options.priority,
            use_cache: options === null || options === void 0 ? void 0 : options.useCache, cache_ttl: options === null || options === void 0 ? void 0 : options.cacheTTLSeconds
        });
    }
}
exports.Translator = Translator;
